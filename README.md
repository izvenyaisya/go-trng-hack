# rng-chaos — Документация

Проект `rng-chaos` — небольшой однопакетный Go-бинарник, реализующий детерминированный трёхуровневый поток генерации случайных данных (TRNG) с возможностями репродуцируемости, смешивания энтропии от разных источников и «отбеливания» выходных данных.

Файлы и структура
- `main.go` — точка входа, HTTP-сервер, маршруты и загрузка/сохранение состояния.
- `entropy.go` — источники энтропии и логика их объединения. Поддерживаемые режимы: `os`, `jitter`, `http`, `mix`, `repro`.
- `trng.go` / `drbg.go` — детерминированный генератор на базе HMAC-DRBG; обёртки для инициализации из seed/транзакции.
- `types.go` — основные структуры данных JSON (например, `SimulationData`, `GenerateParams`, `Transaction`, `GenerationProvenance`).
- `blockchain.go` / `store.json` — хранение транзакций в памяти и сохранение состояния на диск (в `store.json`).
- `stats.go`, `motion.go`, `render.go` — вспомогательные модули для статистики, визуализации/рендеринга и симуляций.
- `internal/nist` — интеграция с тестами NIST (платформо-зависимая часть).
- `tools/` — набор утилит для воспроизведения и отладки:
  - `run_generate.go` — пример запроса `/generate` и последующего извлечения статистики.
  - `run_generate_info.go` — пример получения `PerHTTPSeeds` для воспроизводимости.

Короткое описание архитектуры
- Поток: Источник энтропии -> Симуляция -> HMAC-DRBG (TRNG) -> Отбеливание (whitening) -> Транзакция и хранение.
- Детерминированность важна: режим `repro` и параметр `seed64` позволяют воссоздать конкретный прогон.
- Пер-HTTP seeds: при использовании HTTP-энтропии отдельные ответы приводят к детерминированным под-сидерам, которые сохраняются в транзакции для воспроизводимости.

Сборка и запуск

Требования
- Go 1.22 (указано в `go.mod`).

Сборка (в корне репозитория):

````markdown
# rng-chaos — Документация

Проект `rng-chaos` — небольшой однопакетный Go-бинарник, реализующий детерминированный трёхуровневый поток генерации случайных данных (TRNG) с возможностями репродуцируемости, смешивания энтропии от разных источников и «отбеливания» выходных данных.

Файлы и структура
- `main.go` — точка входа, HTTP-сервер, маршруты и загрузка/сохранение состояния.
- `entropy.go` — источники энтропии и логика их объединения. Поддерживаемые режимы: `os`, `jitter`, `http`, `mix`, `repro`.
- `trng.go` / `drbg.go` — детерминированный генератор на базе HMAC-DRBG; обёртки для инициализации из seed/транзакции.
- `types.go` — основные структуры данных JSON (например, `SimulationData`, `GenerateParams`, `Transaction`, `GenerationProvenance`).
- `blockchain.go` / `store.json` — хранение транзакций в памяти и сохранение состояния на диск (в `store.json`).
- `stats.go`, `motion.go`, `render.go` — вспомогательные модули для статистики, визуализации/рендеринга и симуляций.
- `internal/nist` — интеграция с тестами NIST (платформо-зависимая часть).
- `tools/` — набор утилит для воспроизведения и отладки:
  - `run_generate.go` — пример запроса `/generate` и последующего извлечения статистики.
  - `run_generate_info.go` — пример получения `PerHTTPSeeds` для воспроизводимости.

Короткое описание архитектуры
- Поток: Источник энтропии -> Симуляция -> HMAC-DRBG (TRNG) -> Отбеливание (whitening) -> Транзакция и хранение.
- Детерминированность важна: режим `repro` и параметр `seed64` позволяют воссоздать конкретный прогон.
- Пер-HTTP seeds: при использовании HTTP-энтропии отдельные ответы приводят к детерминированным под-сидерам, которые сохраняются в транзакции для воспроизводимости.

Сборка и запуск

Требования
- Go 1.22 (указано в `go.mod`).

Сборка (в корне репозитория):

```powershell
gofmt -w .
go build
```

Запуск сервера:

```powershell
go run .
```

По умолчанию сервер слушает на `:4040` (см. `main.go`).

HTTP API

- `GET`/`POST /generate` — основной endpoint. Параметры (через query или JSON):
  # rng-chaos — Документация (подробная)

  Проект `rng-chaos` — однопакетный Go-бинарник, реализующий детерминированный TRNG-поток с возможностями воспроизводимости, смешения энтропии из разных источников и отбеливания (whitening) выходных данных.

  Содержимое репозитория (основное):
  - `main.go` — запуск HTTP-сервера, маршруты, загрузка/сохранение состояния.
  - `entropy.go` — источники энтропии и их комбинирование (`deriveSeed`, `rawFromHTTP`).
  - `trng.go`, `drbg.go` — HMAC-DRBG и обёртки для инициализации из seed/транзакции.
  - `types.go` — JSON-структуры: `SimulationData`, `GenerateParams`, `Transaction`, `GenerationProvenance`, `Block`.
  - `blockchain.go` / `store.json` — in-memory хранилище транзакций и сериализация на диск.
  - `stats.go`, `motion.go`, `render.go` — статистика, законы движения и рендер/симуляция.
  - `tools/` — утилиты для воспроизведения и отладки (например, `run_generate.go`, `run_generate_info.go`).

  Коротко об архитектуре
  - Поток: Источник энтропии -> Симуляция -> HMAC-DRBG (TRNG) -> Whitening -> Транзакция -> Сохранение в `store.json`.
  - Режим `repro` + `seed64` обеспечивает детерминированность (включая `PerHTTPSeeds` для HTTP-энтропии).

  Требования и запуск
  - Go 1.22 (см. `go.mod`).

  Сборка и запуск (в корне репозитория):

  ```powershell
  gofmt -w .
  go build
  go run .
  ```

  По умолчанию сервер слушает на `:4040` (см. `main.go`).

  HTTP API — кратко
  - `GET`/`POST /generate` — создать генерацию. Параметры (query или JSON): `entropy` (mode), `seed64` (для repro), `whiten` и параметры симуляции. Возвращает JSON с `id` транзакции.
  - `GET /tx/{id}/info` — полная информация о транзакции (включая `PerHTTPSeeds`).
  - `GET /tx/{id}/trng?n=<N>&format=hex|bytes` — прочитать N байт из TRNG для транзакции.
  - `GET /tx/{id}/stats` — статистика/результаты симуляции (`SimulationData`).

  Дальнейшие разделы описывают внутренности `/generate`, формат `store.json`, псевдо-блокчейн и что является цифровым отпечатком генерации (fingerprint).

  ## Внутреннее устройство `/generate` — пошагово

  Ниже — подробный поток событий при вызове `/generate`.

  1) Парсинг входа
    - Параметры десериализуются в `GenerateParams` (см. `types.go`): `Count`, `Entropy`, `Motion`, `Whiten`, и т.д.

  2) Сбор энтропии и derivation
    - В зависимости от `EntropySpec.Mode` (`os`, `jitter`, `http`, `mix`, `repro`) выбирается стратегия:
      - `os` — системный RNG (non-reproducible).
      - `jitter` — измерение таймингов/джиттера.
      - `http` — запросы к URL из `EntropySpec.HTTP`; ответы детерминируются в per-HTTP seed'ы.
      - `mix` — смешение нескольких источников.
      - `repro` — используется `EntropySpec.Seed64` как мастер-сид для полного воспроизведения.

    - `deriveSeed` (в `entropy.go`) агрегирует входные куски энтропии и возвращает финальный мастер-сид. При наличии HTTP-энтропии также вычисляются `PerHTTPSeeds` (массив int64) — они сохраняются в `GenerationProvenance.PerHTTPSeeds`.

  3) Инициализация TRNG (HMAC-DRBG)
    - Сгенерированный мастер-сид передаётся в DRBG (`NewTRNGFromSeed` / `NewTRNGFromTx`), который создаёт воспроизводимый поток байт.

  4) Симуляция
    - TRNG управляет параметрами симуляции; результат — `SimulationData` (пути точек, параметры канвы и т.д.).
    - JSON от `SimulationData` хэшируется SHA256 и сохраняется как `Transaction.DataHash`.

  5) Генерация окончательных байт и whitening
    - Генерируются запрошенные `Count` бит/байт из TRNG.
    - Если указан `Whiten` (`off`|`hmac`|`aes`|`hybrid`), к байтам применяется соответствующий отбеливающий алгоритм.
    - Итоговый байтовый массив хэшируется SHA256 и записывается в `Transaction.BitsHash`.

  6) Публикация — компактный отпечаток
    - Вычисляется `Published` как HKDF или аналог над `BitsHash` и `DataHash` (короткая сигнатура согласованности между симуляцией и битами).

  7) Сохранение транзакции и обновление цепочки
    - Формируется `Transaction` со всеми метаданными: `TxID`, `CreatedAt`, `Seed`, `Sim`, `DataHash`, `BitsHash`, `Published`, `Provenance`.
    - Создаётся новый `Block` для псевдо-блокчейна (см. `types.Block`), где `DataHash`/`Published` используется как полезная нагрузка.
    - Изменённое хранилище сериализуется в `store.json`.

  ## `/tx` endpoints и воспроизводимость

  - `GET /tx/{id}/info`
    - Возвращает полную структуру `Transaction`. Полезно для извлечения `Provenance.PerHTTPSeeds` и параметров симуляции.

  - `GET /tx/{id}/trng?n=<N>&format=hex|bytes`
    - Сервер восстанавливает TRNG из `Transaction.Seed` и `Provenance` и отдаёт N байт в указанном формате. Это гарантирует, что при том же `store.json` и неизменном коде вы получите тот же поток байт.

  - `GET /tx/{id}/stats`
    - Возвращает `SimulationData`/статистику для анализа и верификации.

  Пример воспроизведения (сохранённый в `store.json`):
  1) Вызов `/tx/{id}/info` — сохранить `Seed` и `PerHTTPSeeds`.
  2) В коде вызвать `NewTRNGFromTx(tx)` (см. `trng.go`) — это даст тот же DRBG, что и при генерации.
  3) Вызвать `/tx/{id}/trng?n=...` для получения потока без необходимости знать внутренние детали.

  ## Формат `store.json` и псевдо-блокчейн

  `store.json` содержит сериализованные структуры хранилища приложения, обычно включая:
  - массив `Transaction` (все транзакции/генерации);
  - массив `Block` — псевдо-блокчейн, где каждый `Block` ссылается на `PrevHash`.

  Структуры (см. `types.go`):
  - `Transaction` — основные поля: `TxID`, `CreatedAt`, `Count`, `Seed`, `Sim` (SimulationData), `DataHash`, `BitsHash`, `Published`, `Provenance`.
  - `Block` — `Index`, `Timestamp`, `TxID`, `DataHash` (published), `PrevHash`, `Hash`.

  Назначение ключевых полей:
  - `Seed` — мастер-сид (int64). Достаточен для восстановления DRBG в режиме `repro` (в сочетании с `PerHTTPSeeds`, если применимо).
  - `DataHash` — SHA256(JSON(SimulationData)). Подтверждает, что симуляция была выполнена однозначно.
  - `BitsHash` — SHA256(итоговых байт после whitening). Подтверждает целостность и неизменность итоговых данных.
  - `Published` — компактный отпечаток (HKDF/label) для быстрой проверки соответствия `DataHash` и `BitsHash`.
  - `Block.PrevHash` / `Block.Hash` — простая связка для проверки порядка и целостности цепочки.

  Почему "псевдо-блокчейн"?
  - Структура похожа на блокчейн (цепочка хэшей и транзакций), но без распределённого консенсуса и POW/Stake — это последовательная локальная история, удобная для аудита и верификации.

  ## Цифровой слепок (fingerprint) генерации

  Для однозначной идентификации и верификации результата используется комбинация полей:
  - `Seed` — мастер-сид;
  - `Provenance` — все параметры генерации (`Entropy`, `Motion`, `Iterations`, `NumPoints`, `PixelWidth`, `CanvasW`, `CanvasH`, `Step`, `Whiten`, `PerHTTPSeeds`);
  - `DataHash` — SHA256(JSON(SimulationData));
  - `BitsHash` — SHA256(итоговых байт после whitening);
  - `Published` — компактная HKDF-метка над `BitsHash` и `DataHash`.

  Если все перечисленные поля совпадают при повторном прогона/проверке — генерация считается воспроизведённой и валидной.

  ## Примеры запросов (PowerShell)

  Создать воспроизводимую генерацию и получить 64 байта в hex:

  ```powershell
  $resp = Invoke-RestMethod -Uri 'http://localhost:4040/generate?entropy=repro&seed64=12345&whiten=aes' -Method Get
  $txid = $resp.id
  Invoke-RestMethod -Uri "http://localhost:4040/tx/$($txid)/trng?n=64&format=hex" -Method Get
  Invoke-RestMethod -Uri "http://localhost:4040/tx/$($txid)/info" -Method Get | ConvertTo-Json -Depth 5
  ```

  Пример curl + jq:

  ```bash
  curl -s "http://localhost:4040/generate?entropy=repro&seed64=12345&whiten=aes" -o gen.json
  jq . gen.json
  id=$(jq -r .id gen.json)
  curl "http://localhost:4040/tx/$id/trng?n=64&format=hex"
  ```

  ## Контракт: вход/выход и ошибки

  - Вход: HTTP-параметры/JSON в соответствии с `GenerateParams`.
  - Успех: HTTP 200 + JSON с `id` транзакции; транзакция добавлена в `store.json`.
  - Ошибки:
    - 4xx — неверные параметры;
    - 5xx — внутренние ошибки (I/O при записи `store.json`, таймауты при `http`-энтропии и т.д.).

  ## Частые проблемы и рекомендации

  - Если используете `entropy=http`, сохраните `PerHTTPSeeds` и/или `store.json` — при недоступности внешних URL они понадобятся для воспроизведения.
  - При изменении алгоритма whitening старые `BitsHash` перестанут совпадать — храните `Provenance.Whiten` вместе с транзакцией.
  - Для тестов воспроизводимости используйте `repro` + фиксированный `seed64` и проверяйте `DataHash`/`BitsHash`.


## Описание JSON-ответа `/tx/{id}/verify`

Когда вы вызываете `GET /tx/{id}/verify`, сервер возвращает JSON с набором булевых флагов и дополнительной информацией для быстрой проверки целостности. Поля и их смысл:

- `chain_valid` (bool): результат проверки псевдо-блокчейна (`validateChain()`). `true` означает, что для каждого блока пересчитанный хэш совпадает с сохранённым и ссылки `PrevHash` корректны.
- `tx_found` (bool): `true`, если транзакция с указанным `tx_id` найдена в `txStore`.
- `data_hash_match` (bool): `true`, если пересчитанный `DataHash` совпадает с сохранённым в `Transaction.DataHash`. Важно: в текущей реализации `DataHash` вычисляется как `SHA256(pathDigest)` — то же самое используется при проверке, поэтому это поле индицирует, что симуляция воспроизводима и не была изменена.
- `bits_hash_match` (bool): `true`, если хэш итоговых бит (`BitsHash`) совпадает при пересчёте. `BitsHash` генерируется как SHA256 от битовой последовательности после применения режима `Whiten`.
- `published_in_chain` (bool): `true`, если значение `Transaction.Published` присутствует в поле `Block.DataHash` соответствующего блока цепочки (т.е. транзакция была «опубликована» в цепочку).

Пример ответа:

```json
{
  "chain_valid": true,
  "tx_found": true,
  "data_hash_match": true,
  "bits_hash_match": true,
  "published_in_chain": true
}
```

Если `data_hash_match` == `false`, это означает, что пересчитанный отпечаток симуляции не совпадает с сохранённым — возможные причины: несогласованность способа хеширования между генерацией и верификацией (устранено в коде), изменение кода `runSimulation` после генерации, или повреждение/изменение `store.json`.

