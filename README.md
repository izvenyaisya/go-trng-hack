# rng-chaos

Простой HTTP-сервер для детерминированной генерации битовых последовательностей из хаотичной симуляции частиц.
Все файлы в проекте находятся в одной папке и имеют `package main` — запустить легко через `go build` и запуск бинарника.

Основная идея

- Источник энтропии (os/jitter/http/mix/repro) определяет только начальный мастер-seed и (при mix/http) per-URL значения.
- По seed и параметрам моделируется движeние множества точек в 2D; закон движения можно менять динамически (см. `law=random`).
- Траектория точек хэшируется; итоговая битовая последовательность детерминирована из хэша траектории, затем опционально отбеливается (whitening).
- Генерация и все артефакты (PNG/JSON/TXT/BIN) сохраняются в in-memory блокчейне (провенанс) и доступны по HTTP.

Кому это нужно

- Исследователям и инженерам, которым нужна воспроизводимая связка визуализации и битовой последовательности.
- Для обучения, демонстраций и генерации тестовых данных.

Быстрый старт (рядовой пользователь)

1. Убедитесь, что у вас установлен Go 1.22+ и настроен PATH.
2. В каталоге проекта выполните:

```powershell
cd D:\projects\proto\rng-chaos
go build -o rng-chaos.exe
./rng-chaos.exe
```

По умолчанию сервер слушает `:8080`.

3. Сгенерировать новый набор данных (пример):

```
GET /generate?count=1000000&entropy=mix&http=https://worldtimeapi.org/api/timezone/Etc/UTC,https://httpbin.org/bytes/512&law=flow&sharp=1.1&smooth=0.9&speed=1.2&iter=10000&points=20&w=1024&h=1024&px=4&step=0.01&whiten=hmac
```

Ответ:
```json
{
  "tx_id": "...",
  "created_at": "2025-10-21T...Z",
  "seed": 1234567890,
  "count": 1000000,
  "replay_hint": { ... }
}
```

4. Скачать артефакты (замените `{id}` на `tx_id`):

```
GET /tx/{id}/png        -> картинка PNG
GET /tx/{id}/json       -> JSON с траекторией
GET /tx/{id}/txt        -> текст с битами (0/1)
GET /tx/{id}/bin        -> бинарный файл (упакованные биты)
GET /tx/{id}/info       -> метаданные транзакции (включая PerHTTPSeeds)
GET /tx/{id}/verify     -> проверка целостности/публикации
GET /tx/{id}/reproduce  -> файл с битами для воспроизведения
GET /tx/{id}/trng?n=64&format=hex -> reproducible TRNG bytes (hex or bin)
```

Пояснения для пользователя

- Если вы хотите точно воспроизвести результат, сохраните поле `seed` и `PerHTTPSeeds` из `/tx/{id}/info` (или seed из `/generate`) — этого достаточно для воспроизведения.
- Параметр `whiten` в `/generate` управляет последующей обработкой битов:
  - `whiten=off` — без отбеливания (по умолчанию);
  - `whiten=on` — быстрый LFSR/xorshift whitening;
  - `whiten=hmac` — криптографический PRF (HMAC-SHA256-CTR) — хороший вариант;
  - `whiten=aes` — AES-CTR поток, ключ/IV деривируются из хэша траектории — рекомендуемый режим для лучшей статистики и совместимости с FIPS-стилем конструкций.
- Параметр `law` поддерживает динамику:
  - одиночный закон (например, `law=flow`),
  - список через запятую (например, `law=flow,sine,spiral`) — каждый тик выбирается случайный из списка,
  - `law=random` — каждый тик выбирается случайно из всех доступных законов.
- `/tx/{id}/trng` возвращает воспроизводимый поток байт, сформированный на основе `seed` и `PerHTTPSeeds` транзакции.

Рекомендуется использовать `whiten=aes` для максимально хороших статистических свойств выходной последовательности.

Примечания

- Сервер использует in-memory хранилище — при перезапуске данные теряются.
- Источник `http` может замедлить генерацию при медленном или недоступном внешнем ресурсе.
- Безопасность: это демонстрационный код, не рекомендуется запускать в публичных сетях без доработок по безопасности.

Дополнительно (могу добавить по запросу)

- persistent storage (sqlite/bolt) для блокчейна;
- асинхронный пул HTTP-энропии с кешем и поворотом источников;
- endpoint `/tx/{id}/trng` с опцией `initial_trng` в ответе `/generate`;
- переключение TRNG на HMAC-SHA256 внутри (если хочешь формальную HMAC-CTR конструкцию).

Статистические тесты и рекомендации
----------------------------------

После усиления этапа развёртывания битов и добавления режима `whiten=aes` (AES-CTR с ключом/IV, деривированными из хэша траектории) статистика на NIST STS и dieharder заметно улучшилась в наших локальных прогонках. Примеры фрагментов выходов (полезно для ориентира):

NIST STS (фрагмент):

1. Frequency (Monobit) Test — 0.390892463426897 — Passed
2. Frequency Test within a Block — 0.27526041503351567 — Passed
3. Runs Test — 0.9850515676095124 — Passed
... (всего 14 тестов — в примере все пройдены)

dieharder (фрагмент):

diehard_birthdays: PASSED
diehard_bitstream: PASSED
diehard_opso/oqso: чувствительны к размеру/формату входа; `whiten=aes` уменьшает слабые проявления.

Как воспроизвести тесты (шаги)
--------------------------------

1) Запустите сервер:

```powershell
cd D:\projects\proto\rng-chaos
go run .
```

2) Сгенерируйте набор с рекомендованными параметрами и `whiten=aes`:

```powershell
Invoke-WebRequest "http://localhost:8080/generate?count=1000000&entropy=mix&http=https://worldtimeapi.org/api/timezone/Etc/UTC&law=random&iter=8000&points=20&whiten=aes" -UseBasicParsing
```

3) Скачайте бинарный файл (`/tx/{id}/bin`) и запустите dieharder (пример для Linux):

```bash
curl -s "http://localhost:8080/tx/{id}/bin" -o out.bin
# dieharder: -g 201 означает file_input_stream
dieharder -a -g 201 -f out.bin
```

4) Для NIST STS (если установлен): укажите `out.bin` в конфигурации STS и запустите соответствующие тесты (NIST требует подготовки входного файла в битовом виде — MSB первого байта считается первым битом).

Рекомендации
------------

- Для наиболее надёжной статистики используйте `whiten=aes`.
- `whiten=hmac` остаётся хорошей альтернативой при требовании криптографического DRBG-подхода.
- Для строгого FIPS/SP800-90A соответствия можно интегрировать полноценный DRBG с управлением reseed и политикой reseed interval.

Если хотите, могу добавить пример CI (GitHub Actions) для автоматической проверки dieharder/NIST при генерации большого файла.
# go-trng-hack
